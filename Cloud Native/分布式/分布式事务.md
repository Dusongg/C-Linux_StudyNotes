

- 事务的特性：原子性、 一致性、隔离性、持久性

- 分布式事务场景

<img src="https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250115%E4%B8%8B%E5%8D%8815001032.png" alt="image-20250115下午15001032" style="zoom:50%;" />



# 消息队列实现

![image-20250115下午22026312](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250115%E4%B8%8B%E5%8D%8822026312.png)

存在的问题：

- 在和数据库交互的本地事务中，夹杂了和第三方组件的 IO 操作，可能存在引发长事务的风险
- 执行消息投递时，可能因为超时或其他意外原因，导致出现消息在事实上已投递成功，但 producer 获得的投递响应发生异常的问题，这样就会导致本地事务被误回滚的问题
- 在执行事务提交操作时，可能发生失败. 此时事务内的数据库修改操作自然能够回滚，然而 MQ 消息一经发出，就已经无法回收了.

# 事务消息

事务消息解决了上述实现中，<u>消息发出但本地事务执行失败导致的数据不一致问题</u>

<img src="https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250115%E4%B8%8B%E5%8D%8822920741.png" alt="image-20250115下午22920741" style="zoom:50%;" />

- 事务消息的局限性：

  **流程高度抽象：** TX Msg 把流程抽象成本地事务+投递消息两个步骤. 然而在实际业务场景中，分布式事务内包含的步骤数量可能很多，因此就需要把更多的内容更重的内容糅合在所谓的“本地事务”环节中，上游 producer 侧可能会存在比较大的压力

  **不具备逆向回滚能力：** 倘若接收消息的下游 consumer 侧执行操作失败，此时至多只能依赖于 MQ 的重发机制通过重试动作的方式提高执行成功率，但是无法从根本上解决下游 consumer 操作失败后回滚上游 producer 的问题. 这一点正是 TX Msg 中存在的最大的局限性.



# [TCC分布式事务](https://www.bytesoft.org/tcc-intro/)

TCC，全称 Try-Confirm-Cancel

- 第一个阶段是 Try，指的是先对资源进行锁定，资源处于中间态但不处于最终态
- 第二个阶段分为 Confirm 和 Cancel，指的是在 Try 操作的基础上，真正提交这次修改操作还是回滚这次变更操作

<img src="https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250115%E4%B8%8B%E5%8D%8892417183.png" alt="image-20250115下午92417183" style="zoom:50%;" />

**Try阶段**

负责检查业务资源，并锁定资源（预留资源）。目标是验证操作的可行性，同时为后续操作做好准备。

示例：扣减库存时，先检查库存是否充足，并预留库存数量。

**Confirm阶段**

尝试操作成功后，真正执行业务逻辑（确认提交事务）。<u>此阶段通常是幂等的</u>，确保即使重复执行也不会有问题。

示例：将预留的库存正式扣减。

**Cancel阶段**

如果 Try 阶段失败，或者 Confirm 阶段失败，则执行 Cancel 阶段，回滚资源到初始状态。<u>此阶段同样需要幂等。</u>

示例：释放预留的库存。



## 悬挂问题

<img src="https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250115%E4%B8%8B%E5%8D%8895306482.png" alt="image-20250115下午95306482" style="zoom:50%;" />

上图悬挂问题可以通过==空回滚==解决：即针对于一笔新的 Transaction ID，在没收到 Try 的前提下，若提前收到了 Cancel 操作，也需要将这个信息记录下来，但不需要对真实的状态数据发生变更



## 优劣势

- 优势：
  - 支持回滚
  - 保证数据一致性：TX Manager 中通过轮询重试机制，保证了在 Confirm 和 Cancel 操作执行失败时，也能够通过重试机制得到补偿
- 劣势：
  - 无法做到即时一致性
  - <u>实现成本高，代码侵入强</u>，需要对所有子模块改造成TCC组件格式