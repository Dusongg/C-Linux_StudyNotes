# 语言/Linux

1. `ulimit -c`

![image-20240307204219639](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240307204219639.png)

> 在Linux中，`ulimit -c`命令用于设置或显示核心转储文件的最大大小。核心转储文件是在程序发生严重错误（如段错误）时生成的一个文件，其中包含了程序运行时的内存映像，可用于调试程序。使用`ulimit -c`命令可以设置核心转储文件的最大大小，单位为块（1块通常是512字节），或者使用`unlimited`表示不限制核心转储文件的大小。
>
> 例如，要将核心转储文件的最大大小设置为无限制，可以使用以下命令：
>
> ```bash
> ulimit -c unlimited
> ```

2. 用mv命令移动文件时，文件的修改时间会发生变化?

> 是的，使用`mv`命令移动文件时，文件的修改时间会发生变化。`mv`命令实际上是在文件系统中重命名文件或将文件移动到另一个目录，这会导致文件的元数据（包括修改时间）发生变化。如果您想要保留原文件的修改时间，可以考虑使用`cp`命令复制文件并保留元数据，然后再删除原文件。

3. 下面关于inode描述错误的是?  <u>答案 ： ?</u>

> A inode能描述文件占用的块数
>
> B inode和文件是一一对应的
>
> C inode描述了文件大小和指向数据块的指针
>
> D 通过inode实现文件的逻辑结构和物理结构的转换



# 系统

1. 存储保护基本含义？

   > 存储保护是计算机系统中的一种机制，用于确保存储器的安全性和隔离性。它的基本含义包括以下几个方面：
   >
   > 1. **数据完整性**：存储保护确保数据在存储器中的完整性，防止数据在存储或检索过程中被篡改或损坏。
   > 2. **访问控制**：存储保护控制对存储器的访问，确保只有经过授权的程序或用户能够读取或修改存储器中的数据。
   > 3. **隔离性**：存储保护确保不同程序或用户的数据彼此隔离，防止它们之间相互干扰或访问彼此的数据。
   > 4. **安全性**：存储保护可以防止恶意程序或用户对系统存储器进行未授权的访问或操作，从而保障系统的安全性。

2. 若系统中只有用户级线程，则处理机调度单位是（）？

3. 调度算法？

> 调度算法：
>
> 1. 先来先服务调度算法（FCFS）：按照进程到达的先后顺序进行调度。
> 2. 短作业优先调度算法（SJF）：选择估计执行时间最短的进程优先执行。
> 3. 优先级调度算法：按照进程的优先级进行调度，优先级高的进程优先执行。
> 4. 时间片轮转调度算法（RR）：每个进程被分配一个时间片，在时间片用完之后，将进程放到就绪队列的末尾，然后选择下一个就绪队列中的进程执行。
> 5. 多级反馈队列调度算法：将进程分为多个队列，每个队列有不同的优先级，新进程进入最高优先级队列，如果一个进程在一个队列的时间片用完了，那么它将被放到一个优先级稍低的队列中，直到执行完成。
> 6. 多级队列调度算法：将进程按照一定的规则分配到不同的队列中，每个队列有不同的调度算法，可以根据不同队列的特点选择适合的调度算法。

> 下列进程调度算法中，（）可能会出现进程长期得不到调度的情况。<u>答案 ： B</u>
>
> A 时间片轮转调度算法
>
> B 强占式静态优先权法
>
> C 非强占式动态优先权法
>
> D 非强占式静态优先权法

4. CPU利用率计算？

   > ![image-20240308205847295](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240308205847295.png)

4. 某台微机安装的是 64 位操作系统，“ 64 位”指的是? 

   - 64位操作系统中的“64位”通常指的是处理器的<u>**字长**</u>。字长是指处理器一次能处理的二进制数据的位数。在64位操作系统中，处理器的字长为64位，这意呈现了处理器在一次操作中能够处理的最大数据大小。这种提升带来了更大的内存地址空间和更高的性能。

4. 如果将固定块大小的文件系统中的块大小设置大一些，会造成（）  <u>答案 ： B</u>

   > A 更好的磁盘吞吐量和更好的磁盘空间利用率
   >
   > B 更好的磁盘吞吐量和更差的磁盘空间利用率
   >
   > C 更差的磁盘吞吐量和更好的磁盘空间利用率
   >
   > D 更差的磁盘吞吐量和更差的磁盘空间利用率

   - 原因：

     当将固定块大小的文件系统中的块大小设置得更大时，会导致更好的磁盘吞吐量和更差的磁盘空间利用率。

     更大的块大小意味着每个文件在磁盘上占用的空间会更大，因为即使文件只有很小的数据，也要占用一个完整的块。这导致了磁盘空间利用率下降，因为会出现更多的空间浪费。

     然而，更大的块大小可以提高磁盘吞吐量。这是因为在读取或写入数据时，系统需要进行磁盘 I/O 操作的次数会减少，因为每次 I/O 操作处理的数据量更大。这减少了寻址和传输数据的开销，提高了磁盘的吞吐量。

4. 在所有非抢占CPU调度算法中，系统平均响应时间最优的是（ ） <u>答案 ： A?</u>

   > A 短任务优先算法
   >
   > B 实时调度算法
   >
   > C 时间片轮转算法
   >
   > D 先来先服务算法

   - 什么是实时调度算法

   > 实时调度算法可以分为**静态优先级调度算法**和**动态优先级调度算法**两种类型。其中，静态优先级调度算法在任务运行前就确定了任务的优先级，而动态优先级调度算法则根据任务的运行情况动态地调整任务的优先级。实时调度算法的目标是确保任务在其截止时间之前完成，并尽量减少任务的响应时间

4. 某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N的取值不超过（5）时系统不会发生死锁 ？

4. 什么是内存抖动（Thrashing）

   > A 非常高的CPU执行活动
   >
   > B 非常频繁的换页活动
   >
   > C 一个极长的执行进程
   >
   > D 一个极大的虚拟内存

   - 内存抖动（Thrashing）是指操作系统在处理过多的页面错误（Page Faults）时，导致大量的页面调度（Page Swapping）操作，从而使系统陷入低效率状态的现象。内存抖动通常发生在系统内存不足时，导致系统频繁地将页面从内存中换出到磁盘上，并从磁盘中换入新的页面，这样的反复调度会消耗大量的CPU和I/O资源，降低系统的性能。

     内存抖动通常是由于进程需要的内存超过了系统实际可用的内存，导致操作系统不得不频繁地将页面从内存中换出换入。为了避免内存抖动，可以通过增加系统内存容量、优化页面置换算法（如LRU算法）、减少系统负载等方式来改善。

4. 页面置换算法有哪些？

- 先进先出（FIFO）：总是淘汰最早进入内存的页面。
- [最近最少使用（LRU）](https://leetcode.cn/problems/lru-cache/submissions/469191848/)：总是淘汰最长时间未被访问的页面。
- [最不经常使用（LFU）](https://leetcode.cn/problems/lfu-cache/submissions/469505449/)：总是淘汰访问次数最少的页面。
- 时钟（Clock）：基于一个时钟指针，每次替换时检查指针指向的页面是否被访问过，如果是，则将其标记为未被访问并移动指针；如果否，则替换该页面。
- 最佳置换算法（OPT）：选择未来最长时间内不会被访问的页面进行置换，是一种理想情况下的算法，但实际上难以实现。
- 最近未使用（NRU）：将页面分为四类，根据最近是否被访问和是否被修改来划分，然后淘汰优先级最低的页面。
- 二次机会（Second-Chance）：类似于时钟算法，但是在页面被选择时会检查其访问位，如果为1则将其置为0并继续检查下一个页面，直到找到一个访问位为0的页面。
- 随机置换算法（Random）：随机选择一个页面进行置换。

11. 下列关于虚拟存储的叙述中，正确的是（）。 <u>答案 ： B</u>

    >  A.虚拟存储只能基于连续分配技术
    >
    > B.虚拟存储只能基于非连续分配技术
    >
    > C.虚拟存储容量只受外存容量的限制
    >
    > D.虚拟存储容量只受内存容量的限制

12. 在缺页处理过程中，操作系统执行以下操作：

    1. **缺页中断处理**：当程序访问的页面不在内存中时，会触发缺页中断。操作系统会捕获这个中断，并进行相应的处理。
    2. **页面调度**：操作系统会根据页面置换算法选择一个页面来替换出去，以便为新页面腾出空间。
    3. **磁盘访问**：如果页面所在的磁盘块不在内存中，操作系统会将磁盘块读入内存。
    4. **更新页表**：操作系统会更新页表，将新加载的页面映射到相应的页框中。
    5. **恢复进程**：如果是用户进程的缺页中断，操作系统会恢复进程

13. 下面选项中，满足短任务优先且不会发生饥饿现象的调度算法是（）<u>答案 ： B</u>

    > A.先来先服务
    >
    > B.高响应比优先
    >
    > C.时间片轮转
    >
    > D.非抢占式短任务优先

    - 高响应比优先算法。这种算法优先调度响应比最高的进程，其中响应比定义为（等待时间 + 服务时间）/ 服务时间。这意味着等待时间较长的进程将具有更高的响应比，因此在一定程度上避免了饥饿现象，并且有利于短作业获得更快的响应。网络

14. 下列选项中，降低进程优先级的合理时机是（）<u>答案 ： A</u>

    > A.进程的时间片用完
    >
    > B.进程刚完成I/O，进入就绪列队
    >
    > C.进程持久处于就绪列队    <u>错误</u>
    >
    > D.进程从就绪状态转为运行态

15. 什么是活跃度失败（liveness failure），哪些情况可能会造成活跃度失败

    - **死锁（Deadlock）**：多个进程或线程因为互相持有对方所需的资源而无法继续执行的情况。例如，进程A持有锁1，等待锁2；而进程B持有锁2，等待锁1，导致两个进程无法继续执行。
    - **饥饿（Starvation）**：某个进程或线程由于优先级较低或竞争条件不利等原因，无法获得所需的资源或锁而无法继续执行的情况。这会导致该进程或线程长时间无法完成任务。
    - **活锁（Livelock）**：进程或线程不断重复相同的操作，但无法取得进展的情况。与死锁不同的是，进程或线程在活锁状态下仍然在运行，但却无法完成所需的任务。

16. 什么是活锁？

    > 活锁是一种特殊的并发问题，它与死锁类似，但是不同之处在于进程或线程仍在运行，但是无法取得进展。以下是一个可能导致活锁的具体场景示例：
    >
    > 假设有两个线程A和B，它们需要在共享资源上进行操作。为了避免竞争条件，它们使用了一种协作机制，比如交替地请求锁。具体流程如下：
    >
    > 1. 线程A尝试获取锁。
    > 2. 如果线程A成功获取了锁，则它会尝试获取另一个资源的锁，并释放第一个资源的锁。
    > 3. 同时，线程B也在尝试获取锁，但是由于A持有第一个资源的锁，B无法获取第一个资源的锁。
    > 4. 当A释放第一个资源的锁时，B可以获取到第一个资源的锁，但是A又立即尝试获取第一个资源的锁。
    > 5. 这样，A和B不断地交替尝试获取锁，但始终无法同时获取到它们需要的两个资源的锁，因此它们都无法继续向前执行，形成了活锁。
    >
    > 在这个例子中，A和B虽然都在运行并尝试获取锁，但是它们无法取得进展，因为它们的操作导致彼此互相阻塞，从而陷入了活锁状态。要解决这个问题，可以使用一些策略来破坏循环等待条件，比如引入随机性或者使用超时机制。

# 数据库



# 基础

1. 十进制数-10的3进制4位补码是多少？

用正数与该负数补码相加得0，正数原反补相同

2. 

