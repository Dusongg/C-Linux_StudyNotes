# 软/硬中断

- 硬中断：指由硬件设备触发的一种中断机制，主要用于通知操作系统需要立即处理某个事件。硬中断的目的是确保计算机对外部设备的请求作出快速响应，例如键盘输入、鼠标点击、网络数据包到达等。
- 软中断：一种由软件触发的中断机制，用于在内核态处理某些无需立即执行的任务，由系统内核线程执行

示例：

> **硬中断与软中断的配合步骤**
>
> ​	1.	**硬中断触发**：
>
> ​	•	网卡收到网络数据包后，发送一个中断信号给 CPU。
>
> ​	•	CPU 响应中断信号，暂停当前任务，跳转到网卡的硬中断处理程序。
>
> ​	2.	**硬中断处理程序**：
>
> ​	•	硬中断处理程序快速执行以下操作：
>
> ​	•	**确认中断**：检查网卡状态，确定中断来源（如数据包到达）。
>
> ​	•	**数据缓存**：从网卡缓冲区中将数据包复制到内存中的一个环形缓冲区（ring buffer）。
>
> ​	•	**触发软中断**：标记一个软中断请求（例如在 Linux 中触发 NET_RX_SOFTIRQ）。
>
> ​	•	硬中断处理完成后，迅速返回，以避免长时间占用 CPU。
>
> ​	3.	**软中断处理**：
>
> ​	•	系统在稍后的时间段（如退出硬中断上下文、任务调度时）检查是否有软中断需要处理。
>
> ​	•	如果有，调度软中断处理程序执行以下任务：
>
> ​	•	**解析数据包**：从环形缓冲区中读取数据包。
>
> ​	•	**协议栈处理**：将数据包传递给操作系统的网络协议栈，进行 IP、TCP 等协议的解析。
>
> ​	•	**通知用户程序**：将解析后的数据传递给用户空间的应用程序。



# 内存管理

## 分段/分页

**分段** 和 **分页** 是计算机内存管理中的两种重要机制，用于将进程的地址空间映射到物理内存中。它们有不同的特点和用途，以下是详细的解释：

---

### 1. 分段 (Segmentation)

#### 概念
分段是一种按照逻辑功能划分内存空间的技术。进程的地址空间被分成若干逻辑片段，每个片段对应特定的功能，比如代码段、数据段、堆栈段等。每个段独立管理，可以动态调整大小。

#### 特点
1. **逻辑划分**：基于程序的逻辑结构（如代码段、数据段）进行划分。  
2. **段表**：每个段都有一个段描述符，段描述符包含段基地址和段长度，段表用于记录这些信息。  
3. **地址结构**：逻辑地址由两个部分组成：  
   - **段号（Segment Number）**：指明访问的是哪个段。  
   - **段内偏移（Offset）**：指定段内的具体地址。  
4. **内存分配灵活**：不同段可以分配在物理内存的不同位置，且大小可以动态调整。

#### 优点
- 容易满足程序的逻辑需求，程序更易开发和维护。
- 支持不同段的权限管理（如代码段只读、数据段可读写）。

#### 缺点
- 内存碎片问题：由于段大小不固定，容易出现外部碎片。

---

### 2. 分页 (Paging)

#### 概念
分页是将内存划分为固定大小的块（称为页框或帧），同时将进程的地址空间划分为等大小的页。分页的目的是实现更高效的内存利用。

#### 特点
1. **固定大小**：页和页框的大小固定（通常是 4KB 或更大）。  
2. **页表**：记录每个逻辑页与物理页框的映射关系。  
3. **地址结构**：逻辑地址分为两部分：  
   - **页号（Page Number）**：指明逻辑地址属于哪个页。  
   - **页内偏移（Offset）**：指明页内的具体地址。  
4. **连续性不要求**：逻辑页在物理内存中可以不连续，解决了外部碎片问题。

#### 优点
- 有效减少外部碎片问题。
- 更容易实现虚拟内存。

#### 缺点
- 页表可能占用较多内存，尤其是进程地址空间很大时。
- 存取时间增加：每次内存访问需要查页表，可能引入额外的延迟。

---

### 3. 分段 vs 分页

| **特性**       | **分段 (Segmentation)**          | **分页 (Paging)**                  |
| -------------- | -------------------------------- | ---------------------------------- |
| **内存划分**   | 按逻辑划分（代码段、数据段等）   | 按固定大小划分（页和页框）         |
| **碎片问题**   | 易出现外部碎片                   | 主要有内部碎片                     |
| **地址结构**   | 段号 + 段内偏移                  | 页号 + 页内偏移                    |
| **连续性要求** | 段内地址必须连续                 | 页在物理内存中不要求连续           |
| **实现复杂度** | 较高，需管理段表                 | 较低，需管理页表                   |
| **适用场景**   | 强调逻辑结构，适用于复杂应用程序 | 强调内存利用率，适用于现代操作系统 |

---

### 4. 分段和分页的结合

现代操作系统（如 Linux、Windows）通常结合分段和分页：  
- **分段** 提供逻辑上的内存划分（如不同的代码段和数据段）。  
- **分页** 解决内存分配





## 缺页中断处理过程

当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生**缺页中断**，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。

缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

如果没有空闲的物理内存，那么内核就会开始进行**回收内存**的工作，回收的方式主要是两种：直接内存回收和后台内存回收。

- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——**触发 OOM （Out of Memory）机制**。

OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。



## 在4G物理内存机器上申请8G空间

- 在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
- 在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
  - 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
  - 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；