# 1. 不允许数组拷贝和赋值——P102

``` cpp
int a[] = {1, 2, 3};
int a2[] = a;	//error:不允许使用一个数组初始化另一个数组
a2 = a; 		//error:不能把一个数组直接赋值给另一个数组
```

- 一些编译器支持数组的赋值，但这是**编译器拓展（compiler extension）**，一般来说，最好避免使用非标准特性

# 2. 导致类的拷贝控制成员被定义为删除函数的原因——P450、476、533、751



# 3 在参数列表后放置*引用限定符*(reference qualifier)

> 引子：
>
> ```cpp
> string s1 = "hello";
> string s2 = "world";
> s1 + s2 = "wow!!!";
> ```
>
> 此处我们对两个`string`的链接结果——**一个右值**，进行了赋值

在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库（C++11）类**任然允许向右值赋值**。

但是，我们可能希望自己的类中阻止这种用法。在此情况下，我们希望**强制左侧运算对象（即，`this`指向的对象）是一个左值**

我们指出`this`的左值/右值属性的方式与定义`const`成员函数相同，即，在**参数列表后放置一个引用限定符**

```cpp
class Foo1 {
public:
	Foo1& operator=(const Foo1&)& { return *this; }
};
class Foo2 {
public:
	Foo2& operator=(const Foo2&)&& { return *this; }
};
int main() {
	Foo1 i, j;
	move(i) = j;   //error
	i = j;   //ok

	Foo2 m, n;
	move(m) = n; //ok
	m = n; //error
	
}

```

# 4 对象函数指针

```cpp
class Test {
public:
	int x = 10;
	int func() {
		return x;
	}
	static int s_func() {
		return 2;
	}
};
int main() {
	Test t;
	//using fp = int(Test::*)();
	int(Test:: * fp)();
	fp = Test::func;      //函数可以取地址也可以不用取地址,函数名会隐式转换为函数指针
	int(*s_fp)();
	s_fp = Test::s_func;

	cout << (t.*fp)() << endl;
	cout << (*s_fp)() << endl;
}
```

# 5 `iostream`用法 + `ctime`

```cpp
class Solution {
public:
    int dayOfYear(string date) {
        tm dt;
        istringstream(date) >> get_time(&dt, "%Y-%m-%d");
        return dt.tm_yday + 1;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/day-of-the-year/solutions/2585579/ge-chong-yu-yan-de-ku-han-shu-xie-fa-pyt-6gdt/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

