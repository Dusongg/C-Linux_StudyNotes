运用场景

hashmap、cfs、epoll、定时器、nginx

# 红黑树的性质

1. 根节点黑，叶子节点红
2. 红节点的两个子节点为黑
3. 对于每个节点，从该节点到叶子节点的所有路径上的黑节点数目相同

![655B00D4D1CF2C0AA1D787F5513E0F97](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/655B00D4D1CF2C0AA1D787F5513E0F97.png)

# 旋转

## 左旋

````cpp
void RotateLeft(Node* parent) {
	Node* cur = parent->_right, * cur_l = cur->_left, * ppnode = parent->_parent;
	//第一步：将cur的左节点与cur的parent相连
	parent->_right = cur_l;
	if (cur_l) cur_l->_parent = parent;
	//第二步：将parent连到cur的左边
	cur->_left = parent;
	parent->_parent = cur;
	//第三步将parent的parent与cur相连：两种情况
	if (parent == _root) {
		_root = cur;
		cur->_parent = nullptr;
	} else {
		(ppnode->_left == parent ? ppnode->_left : ppnode->_right) = cur;
		cur->_parent = ppnode;
	}
}
```

![image-20240223230910696](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240223230910696.png)

## 右旋

```cpp
//与左旋类似
void RotateRight(Node* parent) {
	Node* cur = parent->_left, * cur_r = cur->_right, * ppnode = parent->_parent;
	parent->_left = cur_r;
	if (cur_r) cur_r->_parent = parent;
	cur->_right = parent;
	parent->_parent = cur;
	if (parent == _root) {
		_root = cur;
		cur->_parent = nullptr;
	} else {
		(ppnode->_left == parent ? ppnode->_left : ppnode->_right) = cur;
		cur->_parent = ppnode;
	}
}
```



# 插入

- 默认新插入节点为红色

## 情况1

